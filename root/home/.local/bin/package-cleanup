#!/usr/bin/env bash
# package-cleanup — review recently installed packages and optionally uninstall them
#
# Usage: package-cleanup [--days N] [--dry-run]
#
#   --days N    Look back N days (default: 7)
#   --dry-run   Show what would be removed without doing it

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

DAYS=7
DRY_RUN=0

usage() {
  cat <<EOF
Usage: $(basename "$0") [--days N] [--dry-run]

  --days N    Look back N days for recently installed packages (default: 7)
  --dry-run   Show what would be removed without actually removing anything
  --help      Show this help message
EOF
  exit 0
}

while [[ $# -gt 0 ]]; do
  case $1 in
    --days)    DAYS="$2"; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    --help|-h) usage ;;
    *) echo "Unknown option: $1"; usage ;;
  esac
done

# Validate --days is a positive integer
if ! [[ "$DAYS" =~ ^[1-9][0-9]*$ ]]; then
  echo -e "${RED}Error:${NC} --days must be a positive integer, got: '$DAYS'"
  exit 1
fi

# pacman log is at /var/log/pacman.log
PACMAN_LOG="/var/log/pacman.log"
if [[ ! -f "$PACMAN_LOG" ]]; then
  echo -e "${RED}Error:${NC} pacman log not found at $PACMAN_LOG"
  exit 1
fi

echo -e "${BLUE}${BOLD}Package Cleanup${NC}"
echo -e "${BLUE}Looking back ${DAYS} day(s) for installed packages...${NC}"
echo ""

# Calculate the cutoff date (YYYY-MM-DD format)
CUTOFF=$(date -d "-${DAYS} days" '+%Y-%m-%d')

# Parse pacman log for installed packages since cutoff
# Log format: [YYYY-MM-DDTHH:MM:SS+ZZZZ] [ALPM] installed <pkg> (<version>)
#         or: [YYYY-MM-DDTHH:MM:SS+ZZZZ] [ALPM] upgraded <pkg> (<old> -> <new>)
mapfile -t INSTALLED < <(
  grep '^\[' "$PACMAN_LOG" \
    | awk -v cutoff="$CUTOFF" '
        /\[ALPM\] installed / {
          # Extract date: [2026-02-18T...] -> 2026-02-18
          match($0, /\[([0-9]{4}-[0-9]{2}-[0-9]{2})/, arr)
          if (arr[1] >= cutoff) {
            # Extract package name (field after "installed")
            for (i=1; i<=NF; i++) {
              if ($i == "installed") { print $(i+1); break }
            }
          }
        }
      ' \
    | sort -u
)

if [[ ${#INSTALLED[@]} -eq 0 ]]; then
  echo -e "${GREEN}No packages installed in the last ${DAYS} day(s).${NC}"
  exit 0
fi

# Filter to only packages that are currently installed
CURRENT=()
for pkg in "${INSTALLED[@]}"; do
  if pacman -Qi "$pkg" &>/dev/null; then
    CURRENT+=("$pkg")
  fi
done

if [[ ${#CURRENT[@]} -eq 0 ]]; then
  echo -e "${GREEN}No currently-installed packages from the last ${DAYS} day(s) (all already removed).${NC}"
  exit 0
fi

echo -e "${BOLD}Found ${#CURRENT[@]} package(s) installed in the last ${DAYS} day(s):${NC}"
echo ""

TO_REMOVE=()

for pkg in "${CURRENT[@]}"; do
  # Get package info
  info=$(pacman -Qi "$pkg" 2>/dev/null)
  version=$(echo "$info" | awk -F': ' '/^Version/{print $2; exit}')
  install_date=$(echo "$info" | awk -F': ' '/^Install Date/{print $2; exit}')
  install_reason=$(echo "$info" | awk -F': ' '/^Install Reason/{print $2; exit}')
  description=$(echo "$info" | awk -F': ' '/^Description/{print $2; exit}')
  installed_size=$(echo "$info" | awk -F': ' '/^Installed Size/{print $2; exit}')

  # Color reason: explicit = yellow, dependency = dim
  if [[ "$install_reason" == *"Explicitly"* ]]; then
    reason_color="${YELLOW}"
    reason_label="explicit"
  else
    reason_color="${CYAN}"
    reason_label="dependency"
  fi

  echo -e "  ${BOLD}${pkg}${NC} ${version}"
  echo -e "    ${description}"
  echo -e "    Installed: ${install_date}  |  Size: ${installed_size}  |  Reason: ${reason_color}${reason_label}${NC}"
  echo ""

  # Ask user
  while true; do
    read -r -p "    Remove ${pkg}? [y/N/q] " answer
    case "${answer,,}" in
      y|yes)
        TO_REMOVE+=("$pkg")
        echo -e "    ${RED}→ Queued for removal${NC}"
        break
        ;;
      n|no|"")
        echo -e "    ${GREEN}→ Keeping${NC}"
        break
        ;;
      q|quit)
        echo ""
        echo -e "${YELLOW}Quit early.${NC}"
        break 2
        ;;
      *)
        echo "    Please answer y, n, or q (quit)"
        ;;
    esac
  done
  echo ""
done

# Summary and removal
if [[ ${#TO_REMOVE[@]} -eq 0 ]]; then
  echo -e "${GREEN}Nothing to remove. Done.${NC}"
  exit 0
fi

echo -e "${BOLD}Packages to remove (${#TO_REMOVE[@]}):${NC}"
for pkg in "${TO_REMOVE[@]}"; do
  echo -e "  ${RED}✗${NC} ${pkg}"
done
echo ""

if [[ $DRY_RUN -eq 1 ]]; then
  echo -e "${YELLOW}[dry-run]${NC} Would run: sudo pacman -Rns ${TO_REMOVE[*]}"
  exit 0
fi

read -r -p "Proceed with removal? [y/N] " confirm
if [[ "${confirm,,}" != "y" && "${confirm,,}" != "yes" ]]; then
  echo -e "${YELLOW}Aborted.${NC}"
  exit 0
fi

echo ""
echo -e "${BLUE}Removing packages...${NC}"
sudo pacman -Rns "${TO_REMOVE[@]}"

echo ""
echo -e "${GREEN}Done.${NC}"
